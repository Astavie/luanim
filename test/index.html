<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Luanim</title>
</head>
<body>
    <p id="stdout"></p>
    <center><canvas id="canvas" width="1280" height="720" style="border:1px solid #000000;"></canvas>
    <br>
    <input type="number" id="frames" value="60">
    <input id="button" type="button" value="play"></input></center>
    <br>
    <textarea id="script" style="width: 100%; height: 100vh;"></textarea>
    <script type="module">
        import { LuaFactory } from "./wasmoon/index.js"

        const stdout = document.getElementById("stdout")
        const canvas = document.getElementById("canvas")
        const script = document.getElementById("script")
        const button = document.getElementById("button")
        const frames = document.getElementById("frames")
        const ctx = canvas.getContext("2d")

        button.addEventListener('click', run)

        async function run() {

            stdout.innerText = ""

            const start = Date.now()
            const print = text => {
                const now = Date.now()
                const diff = (now - start) / 1000
                stdout.innerText += `[${diff}] ${text}\n`
            }

            let clip = false

            const factory = new LuaFactory("./wasmoon/glue.wasm")
            await factory.mountFile("ir.lua", await (await fetch("./lua/ir.lua")).text())
            await factory.mountFile("luanim.lua", await (await fetch("./lua/luanim.lua")).text())
            await factory.mountFile("shapes.lua", await (await fetch("./lua/shapes.lua")).text())
            await factory.mountFile("vector.lua", await (await fetch("./lua/vector.lua")).text())
            await factory.mountFile("tweens.lua", await (await fetch("./lua/tweens.lua")).text())
            const lua = await factory.createEngine()

            const thread = lua.global.newThread()
            const threadIndex = lua.global.getTop()

            const draw = (buffer, size) => {
                let index = 0
                while (index < size) {
                    const old = index
                    const num = (i) => {
                        if (index < old + i + 1) index = old + i + 1
                        return thread.lua.module.getValue(buffer + (i + old) * 8, 'double')
                    }
                    const str = (i) => {
                        if (index < old + i + 1) index = old + i + 1
                        const ptr = thread.lua.module.getValue(buffer + (i + old) * 8, 'i8*')
                        const s = thread.lua.module.UTF8ToString(ptr)
                        thread.lua.module._free(ptr)
                        return s
                    }

                    const instr = num(0)
                    switch (instr) {
                        case 2: // TRANSFORM
                            ctx.resetTransform()
                            ctx.translate(canvas.width / 2, canvas.height / 2)
                            ctx.scale(canvas.width / 2 / 256, canvas.width / 2 / 256)
                            ctx.transform(num(1), num(2), num(3), num(4), num(5), num(6))
                            break
                        case 17: // IDENTITY
                            ctx.resetTransform()
                            ctx.translate(canvas.width / 2, canvas.height / 2)
                            ctx.scale(canvas.width / 2 / 256, canvas.width / 2 / 256)
                            break
                        case 19: // CIRCLE
                            ctx.beginPath()
                            ctx.arc(num(1), num(2), num(3), 0, 2 * Math.PI)
                            ctx.fill()
                            break
                        default:
                            print("UNKNOWN " + instr)
                            break
                    }
                }
            }

            const fpDraw = thread.lua.module.addFunction(draw, 'vii')
            const fpEmit = thread.lua.module._luanim_emitter(fpDraw)

            try {
                // open script
                thread.loadString(script.value)
                thread.assertOk(thread.lua.lua_pcallk(thread.address, 0, -1, 0, 0, null))

                // loop
                let args = 1
                let func = thread.lua.lua_gettop(thread.address)
                thread.lua.lua_pushvalue(thread.address, -1)
                thread.lua.lua_pushnumber(thread.address, frames.value)

                const num = (i) => thread.lua.luaL_checknumber(thread.address, func + 1 + i)
                const pop = () => {
                    thread.lua.lua_settop(thread.address, func)
                    thread.lua.lua_pushvalue(thread.address, -1)
                }

                await new Promise(r => {
                    let interval
                    const frame = () => {
                        ctx.save()
                        ctx.resetTransform()
                        ctx.clearRect(0, 0, canvas.width, canvas.height)
                        ctx.restore()

                        while (true) {
                            thread.assertOk(thread.lua.lua_pcallk(thread.address, args, -1, 0, 0, null))

                            if (thread.lua.lua_gettop(thread.address) == func) {
                                // the end
                                if (interval) clearInterval(interval)
                                thread.lua.module._luanim_draw()

                                r()
                                return
                            }

                            const instr = num(0)
                            args = 0

                            switch (instr) {
                                case 1: // FRAME
                                    // const frame = num(1)
                                    // print("FRAME " + frame)
                                    pop()
                                    thread.lua.module._luanim_draw()
                                    return
                                case 16: // FPS
                                    if (interval) clearInterval(interval)
                                    interval = setInterval(frame, 1000 / num(1))
                                    pop()
                                    break
                                case 21: // EMIT
                                    pop()
                                    thread.lua.lua_pushcclosure(thread.address, fpEmit, 0)
                                    args = 1
                                    break
                                default:
                                    emit(thread.address, func + 1)
                                    pop()
                                    break
                            }
                        }
                    }
                    frame()
                })
            } finally {
                thread.lua.module.removeFunction(fpEmit)
                lua.global.close()
                lua.global.remove(threadIndex)
            }

            // const instance = await luanim({ 
            //     print,
            //     frame_start() {
            //         ctx.save()
            //         ctx.resetTransform()
            //         ctx.clearRect(0, 0, canvas.width, canvas.height)
            //         ctx.restore()
            //     },
            //     draw_ellipse(x, y, rx, ry, rot) {
            //         if (!clip) ctx.beginPath()
            //         ctx.ellipse(x, y, rx, ry, rot, 0, 2 * Math.PI)
            //         if (!clip) ctx.fill()
            //     },
            //     path_start(x, y) {
            //         if (!clip) ctx.beginPath()
            //         ctx.moveTo(x1, y1)
            //     },
            //     draw_bezier(cx1, cy1, cx2, cy2, x, y) {
            //         ctx.bezierCurveTo(cx1, cy1, cx2, cy2, x, y)
            //     },
            //     path_end() {
            //         if (!clip) ctx.stroke()
            //     },
            //     set_line_width(lineWidth) {
            //         ctx.lineWidth = lineWidth
            //     },
            //     set_matrix(a, b, c, d, e, f) {
            //         ctx.resetTransform()
            //         ctx.translate(canvas.width / 2, canvas.height / 2)
            //         ctx.scale(canvas.width / 2 / 256, canvas.width / 2 / 256)
            //         ctx.transform(a, b, c, d, e, f)
            //     },
            //     draw_text(x, y, size, text) {
            //         if (clip) return // no support for text as clip path
            //         ctx.save()
            //         ctx.translate(x, y)
            //         ctx.scale(size, size)
            //         ctx.fillText(text, 0, 0)
            //         ctx.restore()
            //     },
            //     draw_rect(x1, y1, x2, y2) {
            //         if (!clip) ctx.beginPath()
            //         ctx.rect(x1, y1, x2, y2)
            //         if (!clip) ctx.fill()
            //     },
            //     measure(text) {
            //         return ctx.measureText(text).width
            //     },
            //     clip_start() {
            //         ctx.save()
            //         ctx.beginPath()
            //         clip = true
            //     },
            //     clip_push() {
            //         clip = false
            //         ctx.clip()
            //     },
            //     clip_pop() {
            //         ctx.restore()
            //     },
            // })
        }
    </script>
</body>
</html>
